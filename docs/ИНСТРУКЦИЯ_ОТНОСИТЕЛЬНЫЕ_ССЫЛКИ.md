# Инструкция: Как работают относительные ссылки на фильтры

## Суть проблемы (РЕШЕНО ✓)

**Было:**
При создании маски из спарсированной стратегии, ссылки на фильтры записывались как абсолютные номера строк (например, `4990, 4993`). При генерации нового TVR файла эти ссылки оставались неизменными, что приводило к неправильным ссылкам.

**Стало:**
Теперь ссылки автоматически конвертируются в относительный формат (`begin+10, begin+13`) и при генерации пересчитываются относительно новой базовой строки.

---

## Как использовать (простая инструкция)

### Шаг 1: Создание маски с относительными ссылками

В ноутбуке `strategy_mask_demo_v2.ipynb` используйте новую функцию:

```python
from src.tvr_service.generator import build_mask_dataframe_from_layout

# Создаем маску - ссылки автоматически станут относительными!
mask_df = build_mask_dataframe_from_layout(
    layout=layout,
    compiled=compiled,
    source_dataframe=tvr_full,
    target_base_stroka=1000,
)
```

**Результат:** В столбцах `InL1`, `InL2`, `OutL1`, `OutL2` вместо абсолютных номеров строк (например, `4990`) будут относительные ссылки (например, `begin+10`).

### Шаг 2: Создание шаблона из маски

```python
from src.tvr_service.templates import build_template_from_mask_file

mask_result = build_template_from_mask_file(
    'mask.xlsx',
    row_alias_column='row_alias',
    marker='#',
)
```

**Важно:** Функция автоматически сохраняет относительные ссылки в шаблоне.

### Шаг 3: Генерация TVR

```python
from src.tvr_service.generator import StrategyGenerator

generator = StrategyGenerator(
    template=mask_result.template,
    strategy_column='strategy_id',
    start_column='start',
)

tvr_df = generator.generate(config_table)
```

**Результат:** Относительные ссылки автоматически конвертируются в абсолютные с учетом значения `start` для каждой стратегии.

---

## Пример работы

### Исходная стратегия (stroka = 4980)
```
stroka: 4980
InL1: 4990, 4993
InL2: 4991
```

### В маске (после конвертации, base = 4980)
```
stroka: 1000
InL1: begin+10, begin+13
InL2: begin+11
```

### ✨ ВАЖНО: Пересборка с изменением offset

Если вы переместили фильтр с offset=10 на offset=2:

```
Было: InL1: begin+10  (указывает на фильтр с offset=10)
Стало: InL1: begin+2  (автоматически обновлено на новый offset!)
```

**Функция автоматически пересчитывает ссылки** при пересборке layout!

### В сгенерированном TVR (start = 1000)
```
stroka: 1000
InL1: 1010, 1013
InL2: 1011
```

### В сгенерированном TVR (start = 2000)
```
stroka: 2000
InL1: 2010, 2013
InL2: 2011
```

---

## Что изменилось в коде

✅ **Автоматическая конвертация** - больше не нужно вручную преобразовывать ссылки
✅ **Обратная совместимость** - старые маски продолжают работать
✅ **По умолчанию включено** - для новых проектов автоматически используется правильный формат

---

## Проверка правильности работы

После создания маски проверьте столбцы с фильтрами:

```python
# Показать ссылки в маске
filter_cols = ['row_alias', 'stroka', 'InL1', 'InL2', 'OutL1', 'OutL2']
print(mask_df[filter_cols].head())
```

Должны быть видны ссылки в формате `begin+X`, а не абсолютные номера строк.

---

## Часто задаваемые вопросы

**Q: Нужно ли что-то менять в существующих проектах?**  
A: Нет, если вы хотите использовать новую функциональность, просто используйте `build_mask_dataframe_from_layout` вместо ручного создания маски.

**Q: Что если я хочу использовать абсолютные ссылки?**  
A: Передайте параметр `convert_references_to_relative=False` в `build_template_from_mask_file`.

**Q: Какие столбцы конвертируются?**  
A: По умолчанию: `InL1`, `InL2`, `OutL1`, `OutL2`, `secIn`, `secOut`. Можно изменить через параметр `reference_columns`.

**Q: Что происходит при пересборке (изменении offset)?**  
A: ✨ **Автоматически пересчитываются ссылки!** Если вы переместили фильтр с offset=10 на offset=2, все ссылки типа `begin+10` автоматически обновятся на `begin+2`.

**Q: Как это работает?**  
A: Функция `build_mask_dataframe_from_layout` строит маппинг `original_stroka -> new_offset` и использует его при конвертации ссылок. Если ссылка указывает на строку, которая была перемещена, используется новый offset.

---

**Документ создан:** 30.09.2025  
**Версия:** 1.0
